//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import Helper.*;
/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class SecondPass<R,A> implements GJVisitor<R,A> {

   public ProcedureList allProcedures;
   public String curProcName;
   public ProcData curProcedure;
   public int spilloffset;
   public int calloffset;
   public boolean labelFlag;
   public String movetemp;
   public String moveflag;
   public ArrayList<String> callTemps;

   public SecondPass(ProcedureList p){
      allProcedures = p;
      curProcedure = null;
      curProcName = null;
      spilloffset = calloffset = 0;
      labelFlag = false;
      movetemp = null;
   }

   public void emit(String s)
   {
      System.out.println(s);
   }

   public String findRegister(String temp, int index, boolean load, RegAllocation alloc)
   {
      RegAllocation ra = curProcedure.varAllocation.get(temp);
      if(ra.reg != null)
      {
         return (ra.reg);
      }
      else
      {
         int relLoc = ra.spillLoc;
         int loc = spilloffset + relLoc;
         alloc.spillLoc = loc;
         if(load)
            emit(" ALOAD v"+index+" SPILLEDARG "+loc);
         return ("v"+index);
      }
   }
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);

      curProcName = "MAIN";
      curProcedure = allProcedures.procedures.get(curProcName);
      int spillcount = curProcedure.noOfSpilledVars;
      int sndParam = spillcount;
      if(!curProcedure.calledProcArgs.isEmpty())
      {
         sndParam += 10;
      }
      spilloffset = 0;
      calloffset = spillcount;
      int thirdParam = curProcedure.maxNoOfArgsInCall;
      emit(" MAIN [0]["+sndParam+"]["+thirdParam+"]");

      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      curProcName = null;
      curProcedure = null;
      emit(" END");
      if(spillcount == 0)
      {
         emit(" // NOTSPILLED\n");
      }
      else
      {
         emit(" // SPILLED\n");
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      labelFlag = true;
      n.f0.accept(this, argu);
      labelFlag = false;
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      curProcName = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      int argcount = Integer.parseInt((String) n.f2.accept(this, argu));
      n.f3.accept(this, argu);
      curProcedure = allProcedures.procedures.get(curProcName);
      int spillcount = curProcedure.noOfSpilledVars;
      int extargs = (argcount-4>0)?(argcount-4):0;
      int saveCalleeCount = curProcedure.saveCalleeCount;
      int sndParam = saveCalleeCount + extargs + spillcount;
      if(!curProcedure.calledProcArgs.isEmpty())
      {
         sndParam += 10;
      }
      spilloffset = saveCalleeCount + extargs;
      calloffset = saveCalleeCount + extargs +spillcount;
      int thirdParam = curProcedure.maxNoOfArgsInCall;
      emit(" "+curProcName+" ["+argcount+"]["+sndParam+"]["+thirdParam+"]");

      int soffset = 0;
      for(int i=0;i<8;++i)
      {
         if(curProcedure.saveCalleeRegFlags.get("s"+i))
         {
            emit(" ASTORE SPILLEDARG "+(extargs+soffset)+" s"+i);
            ++soffset;
         }
      }

      RegAllocation ra;
      String reg;
      String temp;
      for(int i=0;i < argcount;++i)
      {
         temp = "TEMP "+i;
         if(curProcedure.allVariables.contains(temp) && !curProcedure.spilledCallArgs.contains(i))
         {
            ra = new RegAllocation();
            reg = findRegister("TEMP "+i, 0, false, ra);
            if(i < 4)
            {
               emit(" MOVE "+reg+" a"+i);
            }
            else
            {
               emit(" ALOAD "+reg+" SPILLEDARG "+(i-4));
            }
            if(ra.spillLoc != -1)
            {
               emit(" ASTORE SPILLEDARG "+ra.spillLoc+" "+reg);
            }
         }
      }

      n.f4.accept(this, argu);

      soffset = 0;
      for(int i=0;i<8;++i)
      {
         if(curProcedure.saveCalleeRegFlags.get("s"+i))
         {
            emit(" ALOAD s"+i+" SPILLEDARG "+(extargs+soffset));
            ++soffset;
         }
      }
      curProcName = null;
      curProcedure = null;
      emit(" END");
      if(spillcount == 0)
      {
         emit(" // NOTSPILLED\n");
      }
      else
      {
         emit(" // SPILLED\n");
      }
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      labelFlag = true;
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      emit(" NOOP");
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      emit(" ERROR");
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      labelFlag = false;
      String temp1 = (String) n.f1.accept(this, argu);
      String lbl = (String) n.f2.accept(this, argu);
      String reg = findRegister(temp1,0,true,new RegAllocation());
      emit(" CJUMP "+reg+" "+lbl);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      String lbl = (String) n.f1.accept(this, argu);
      emit(" JUMP "+lbl);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      String temp1 = (String) n.f1.accept(this, argu);
      String offset = (String) n.f2.accept(this, argu);
      String temp2 = (String) n.f3.accept(this, argu);
      String reg1 = findRegister(temp1, 0, true, new RegAllocation());
      String reg2 = findRegister(temp2, 1, true, new RegAllocation());
      emit(" HSTORE "+reg1+" "+offset+" "+reg2);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      String temp1 = (String) n.f1.accept(this, argu);
      String temp2 = (String) n.f2.accept(this, argu);
      String offset = (String) n.f3.accept(this, argu);
      RegAllocation ra1 = new RegAllocation();
      String reg1 = findRegister(temp1, 0, false, ra1);
      String reg2 = findRegister(temp2, 1, true, new RegAllocation());
      emit(" HLOAD "+reg1+" "+reg2+" "+offset);
      if(ra1.spillLoc != -1)
      {
         emit(" ASTORE SPILLEDARG "+ra1.spillLoc+" "+reg1);
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      movetemp = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      movetemp = null;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      labelFlag = false;
      n.f0.accept(this, argu);
      String se = (String) n.f1.accept(this, argu);
      if(se.contains("TEMP "))
      {
         String reg = findRegister(se, 0, true, new RegAllocation());
         emit(" PRINT "+reg);
      }
      else
      {
         emit(" PRINT "+se);
      }
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(n.f0.which == 3)
      {
         String se = (String) n.f0.accept(this,argu);
         String src = se;
         if(se.contains("TEMP "))
         {
            src = findRegister(se, 0, true, new RegAllocation());
         }
         RegAllocation dra = new RegAllocation();
         String dreg = findRegister(movetemp, 1, false, dra);
         if(dreg != src)
            emit(" MOVE "+dreg+" "+src);
         if(dra.spillLoc != -1)
         {
            emit(" ASTORE SPILLEDARG "+dra.spillLoc+" "+dreg);
         }
      }
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String se = (String) n.f3.accept(this, argu);
      String opnd = se;
      if(se.contains("TEMP "))
      {
         opnd = findRegister(se, 1, true, new RegAllocation());
      }
      emit(" MOVE v0 "+opnd);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String se = (String) n.f1.accept(this, argu);
      callTemps = new ArrayList<String>();
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      for(int i=0;i<10;++i)
      {
         emit(" ASTORE SPILLEDARG "+(calloffset+i)+" t"+i);
      }
      String reg;
      int argno = 0;
      for(String arg : callTemps)
      {
         reg = findRegister(arg, 0, true, new RegAllocation());
         if(argno < 4)
            emit(" MOVE a"+argno+" "+reg);
         else
            emit(" PASSARG "+(argno-3)+" "+reg);
         ++argno;
      }
      if(se.contains("TEMP "))
      {
         reg = findRegister(se, 0, true, new RegAllocation());
         emit(" CALL "+reg);
      }
      else
      {
         emit(" CALL "+se);
      }

      for(int i=0;i<10;++i)
      {
         emit(" ALOAD t"+i+" SPILLEDARG "+(calloffset+i));
      }

      RegAllocation mra = new RegAllocation();
      reg = findRegister(movetemp, 0, false, mra);
      if(mra.spillLoc == -1)
      {
         emit(" MOVE "+reg+" v0");
      }
      else
      {
         emit(" ASTORE SPILLEDARG "+mra.spillLoc+" v0");
      }
      callTemps = null;
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String se = (String) n.f1.accept(this, argu);
      String opnd = se;
      if(se.contains("TEMP "))
      {
         opnd = findRegister(se, 0, true, new RegAllocation());
      }
      RegAllocation dra = new RegAllocation();
      String dreg = findRegister(movetemp, 1, false, dra);
      emit(" MOVE "+dreg+" HALLOCATE "+opnd);
      if(dra.spillLoc != -1)
      {
         emit(" ASTORE SPILLEDARG "+dra.spillLoc+" "+dreg);
      }     
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String op = (String) n.f0.accept(this, argu);
      String temp1 = (String) n.f1.accept(this, argu);
      String se = (String) n.f2.accept(this, argu);
      String reg1 = findRegister(temp1, 0, true, new RegAllocation());
      String opnd2 = se;
      if(se.contains("TEMP "))
      {
         opnd2 = findRegister(se, 1, true, new RegAllocation());
      }
      RegAllocation dra = new RegAllocation();
      String dreg = findRegister(movetemp, 0, false, dra);
      emit(" MOVE "+dreg+" "+op+" "+reg1+" "+opnd2);
      if(dra.spillLoc != -1)
      {
         emit(" ASTORE SPILLEDARG "+dra.spillLoc+" "+dreg);
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      String op;
      int ch = n.f0.which;
      if(ch == 0)
         op = "LE";
      else if(ch == 1)
         op = "NE";
      else if(ch == 2)
         op = "PLUS";
      else if(ch == 3)
         op = "MINUS";
      else if(ch == 4)
         op = "TIMES";
      else
         op = "DIV";
      _ret = (R) op;
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String num = (String) n.f1.accept(this, argu);
      if(callTemps != null)
      {
         callTemps.add("TEMP "+num);
      }
      _ret = (R)("TEMP "+num);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = (R) n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      _ret = (R) n.f0.tokenImage;
      if(labelFlag)
      {
         emit((String)_ret);
      }
      return _ret;
   }

}
